#!/usr/bin/env python
# coding: utf-8

# # Imports

# ## PyGAD

# In[1]:


import pygad
import numpy
import os
import sys
import Bio
import pandas as pd
from general_functions import *
from metrics import *
import hashlib
import subprocess
import time


# ## spliceAI

# In[2]:


# from metrics import splicing_gpu
# from multiprocessing import Pool


# # Multi-threa

# In[3]:


# from multiprocessing import Pool
# import subprocess 


# # CAI

# In[4]:


# import time
# import hashlib


# # BAI

# In[5]:


# my_env = os.environ.copy()
# my_env["PATH"] = "/data/software/anaconda3/envs/bfx/lib/perl5/site_perl/5.22.0:/data/software/anaconda3/pkgs/texlive-selected-20160715-1/share/texlive/tlpkg:" + my_env["PATH"]


# In[6]:


# def readFasta( fastaFile: str ):
#     fastaId = ''
#     fastaSeq = ''
#     if os.path.exists( fastaFile ):
#         try:
#             with open( fastaFile, "r") as handle:
#                 cont = 0
#                 fastaIds = []
#                 fastaSeqs = []
#                 for record in SeqIO.parse( handle, "fasta"):
#                     fastaIds.append(record.id)
#                     fastaSeqs.append(record.seq)
#         except IOError as e:
#             print( "I/O error({0}): {1}".format(e.errno, e.strerror) )
#         except:
#             print( "Unexpected error:", sys.exc_info()[0] )
#     else:
#         print("File does not exist:" + fastaFile )
#         exit(2)
#     return (fastaIds, fastaSeqs)


# def predictSites( fastaSeq: str ):
#     #config = tf.compat.v1.ConfigProto(intra_op_parallelism_threads=100,
#     #                        inter_op_parallelism_threads=100,
#     #                        allow_soft_placement=True,
#     #                        device_count = {'CPU': 100})
#     #session = tf.compat.v1.Session(config=config)
#     #K.set_session(session)
#     context = 10000
#     keras.backend.set_learning_phase(0)
#     paths = ('models/spliceai{}.h5'.format(x) for x in range(1, 6))
#     models = [load_model(resource_filename('spliceai', x), compile=False ) for x in paths]
#     x = one_hot_encode('N'*(context//2) + fastaSeq + 'N'*(context//2))[None, :]
#     y = np.mean([models[m].predict(x) for m in range(5)], axis=0)
#     acceptor_prob = y[0, :, 1]
#     donor_prob = y[0, :, 2]
#     coord = list( range(1, len( donor_prob ) ) )
#     return ( coord, acceptor_prob, donor_prob )

# def savePredictions( predictions: list, outfile: str ):
#     original_stdout = sys.stdout # Save a reference to the original standard output
#     with open( outfile, "w") as handle:
#         sys.stdout = handle # Change the standard output to the file we created.
#         print("coord","acceptor_prob","donor_prob", sep="\t")
#         for row_ind in range(0,len( predictions[0]) - 1):
#             for col in predictions:
#                 print( col[row_ind], end="\t" )
#             print("")
#     sys.stdout = original_stdout # Reset the standard output to its original value


# # Start

# ## Parameters

# ### Metrics

# In[7]:


cai_on = True
bai_on = True
sps_on = False
cpg_on = True
pas_on = False


# ### Weights

# In[8]:


cai_w = 1
bai_w = 1
sps_w = 1
cpg_w = 1
pas_w = 1


# ### Locations

# In[9]:


ga_input = '/grid/home/nbourgeois/data/test_sequences/hidua/hidua.pep.fas'
# ga_input = '/grid/home/nbourgeois/data/test_sequences/eGFP/pKITR-LP1-eGFP-004_protein_seq.fa'
cai_index_loc = 'CoCoPUTs_codon_usage/codon_usage/Brain_Cerebellum.codon.txt'
bai_index_loc = 'CoCoPUTs_codon_usage/bicodon_usage/Brain_Cerebellum.bicodon.txt'

codon_usage_table_loc = 'codon_usage.getex.txt'


# # Algorithm

# ### Read in File

# In[10]:


(keys, seqs) = readFasta(ga_input)
if len(seqs) == 1:
    aa_seq=str(seqs[0])


# ### Initialize Parameters
# - gene_space
# - codon_to_int dictionary

# In[11]:


# codon_usage_table = pd.read_csv(codon_usage_table_loc,sep='\t')
# forward_table = pd.Series(codon_usage_table.AA.values,index=codon_usage_table.Codon).to_dict()

# back_table = {}
# for key in forward_table:
#     val = forward_table[key]
#     if val not in back_table.keys():
#         back_table[val] = [key]
#     else:
#         back_table[val].append(key)

# codon_to_int = {}
# i=0
# for codon in forward_table.keys():
#     codon_to_int[codon] = i
#     codon_to_int[i] = codon
#     i += 1
        
# gene_space = []
# for aa in aa_seq:
#     all_cds = back_table[aa]
#     gene_space.append(all_cds)
global codon_to_int

codon_to_int, gene_space = init_parameters(codon_usage_table_loc, aa_seq)
    
gene_space_int = [[codon_to_int[x] for x in y] for y in gene_space]


# # Fitness Function

# In[12]:


# def get_sps(seq_aa):
    
#     prediction_ind, acceptor_prob, donor_prob = splicing_gpu.predictSites( seq_aa )
#     print('SPS called.')
# #     val = 1-np.mean(donor_prob)
#     if any(acceptor_prob > .8) or any(donor_prob > .8):
#         val = 1 
#     else: 
#         val = 0

#     return(val)

# def get_bai(seq_aa,bai_index_loc):
#     my_env = os.environ.copy()
#     my_env["PATH"] = "/data/software/anaconda3/envs/bfx/lib/perl5/site_perl/5.22.0:"+
#         "/data/software/anaconda3/pkgs/texlive-selected-20160715-1/share/texlive/tlpkg:" + 
#         my_env["PATH"]
#     bai_script = ' '.join(['nice','perl','bai.pl',seq_aa,bai_index_loc])
#     out = subprocess.run(bai_script, shell=True, capture_output=True, env=my_env).stdout
#     bai = float(out)
#     return(bai)

# def get_cai(seq_aa, cai_index_loc):
#     seq_aa_bin = seq_aa.encode('utf-8')
#     hash_object = hashlib.sha1(seq_aa_bin)
#     hex_dig = hash_object.hexdigest()
#     idx = hex_dig[0:6]
    
#     if not os.path.isdir('tmp'):
#         os.mkdir('tmp') 
#     file_fa = os.path.join('tmp', str(idx)+'.fa')
#     file_ca = os.path.join('tmp', str(idx)+'.ca')
    
#     with open(file_fa ,'w') as fileo:
#         fileo.write('>fa\n'+seq_aa+'\n')
        
#     cmd = 'nice cai ' + file_fa + ' -cfile ' + cai_index_loc + ' -outfile '+ file_ca
#     subprocess.Popen(cmd, shell=True)

#     # wait for file to refresh
#     i=0
#     while not os.path.isfile(file_ca):
#         if i > 100:
#             print('File not generated:'+file_ca)
#             return(0)
#         time.sleep(.1)
#         i+=1
    
#     with open(file_ca,'r') as fileo:
#         lines = fileo.readline()
    
#     cai = float(lines.split()[-1])
        
# #     cmd = 'rm '+ file_ca +' '+ file_ca
# #     subprocess.Popen(cmd, shell=True)
    
#     return(cai)


# def get_cpg(seq):
#     count = seq.count("CG")
#     cpg_score = ( len(seq) - count * 2 ) / len(seq)  
#     return(cpg_score)

# def get_pas(seq_aa):
#     seq_aa_bin = seq_aa.encode('utf-8')
#     hash_object = hashlib.sha1(seq_aa_bin)
#     hex_dig = hash_object.hexdigest()
#     idx = hex_dig[0:6]
    
#     if not os.path.isdir('tmp'):
#         os.mkdir('tmp') 
#     file_fa = os.path.join('tmp', str(idx)+'.fa')
#     file_prefix = os.path.join('tmp', str(idx)+'_pasta')
#     file_out = file_prefix+'.pas.txt'
    
#     if not os.path.isfile(file_fa):
#         with open(file_fa ,'w') as fileo:
#             fileo.write('>fa\n'+seq_aa+'\n')
        
#     cmd = 'nice sh deep_pasta.sh ' + file_fa + ' ' + file_prefix
#     subprocess.Popen(cmd, shell=True)

#     # wait for file to refresh
#     i=0
#     while not os.path.isfile(file_out):
#         if i > 3000:
#             print('File not generated:'+file_out)
#             return(0)
#         time.sleep(.1)
#         i+=1
    
#     with open(file_out,'r') as fileo:
#         lines = fileo.readline()
    
# #     print(lines)
#     if len(lines.split()) < 2:
#         return(0)
    
#     pas = float(lines.split()[-1])
            
#     return(pas)

def get_memory():
    with open('/proc/meminfo', 'r') as mem:
        free_memory = 0
        for i in mem:
            sline = i.split()
            if str(sline[0]) in ('MemFree:', 'Buffers:', 'Cached:'):
                free_memory += int(sline[1])
    return free_memory


def fitness_func(solution, solution_idx):
    
    if not type(solution) is str:
        seq_aa = ''.join([codon_to_int[x] for x in solution])
    else:
        seq_aa = solution
#     print(solution_idx)

    tmp_dict = {}
    
    #Check for redundancy
    if seq_aa in all_sols.keys():
        fitness = all_sols[seq_aa]['fitness']

    else:
        fitness = 0
        total_weight=0
        
        if cai_on:
            cai = get_cai(seq_aa, cai_index_loc)
            fitness += cai*cai_w
            total_weight += cai_w
            tmp_dict['cai'] = cai
        
        if bai_on:
            bai = get_bai(seq_aa, bai_index_loc)
            fitness += bai*bai_w
            total_weight += bai_w
            tmp_dict['bai'] = bai
            
        if cpg_on:
            cpg = get_cpg(seq_aa)
            fitness += cpg*cpg_w
            total_weight += cpg_w
            tmp_dict['cpg'] = cpg

        if sps_on:
            sps = get_sps(seq_aa)
            print('SPS retuned.')

            fitness += sps*sps_w
            total_weight += sps_w
            tmp_dict['sps'] = sps

        if pas_on:
            pas = get_pas(seq_aa)
            fitness += pas*pas_w
            total_weight += pas_w
            tmp_dict['pas'] = pas

        fitness = fitness/total_weight
        tmp_dict['fitness'] = fitness
        all_sols[seq_aa] = tmp_dict
        
        #     output = numpy.sum(solution*function_inputs)
        #     fitness = 1.0 / numpy.abs(output - desired_output)
    
    return fitness


# # Genetic Algorithm

# In[13]:


"""
Given the following function:
    y = f(w1:w6) = w1x1 + w2x2 + w3x3 + w4x4 + w5x5 + 6wx6
    where (x1,x2,x3,x4,x5,x6)=(4,-2,3.5,5,-11,-4.7) and y=44
What are the best values for the 6 weights (w1 to w6)? We are going to use the genetic algorithm to optimize this function.
"""

# def convert_aa_int():
    
desired_output = 1 # Function output.
all_sols = {}

fitness_function = fitness_func

num_generations = 1 # Number of generations.
num_parents_mating = 5 # Number of solutions to be selected as parents in the mating pool.

# To prepare the initial population, there are 2 ways:
# 1) Prepare it yourself and pass it to the initial_population parameter. This way is useful when the user wants to start the genetic algorithm with a custom initial population.
# 2) Assign valid integer values to the sol_per_pop and num_genes parameters. If the initial_population parameter exists, then the sol_per_pop and num_genes parameters are useless.
sol_per_pop = 5 # Number of solutions in the population.
num_genes = len(gene_space)

# init_range_low = -2
# init_range_high = 5

parent_selection_type = "sss" # Type of parent selection.
keep_parents = 5 # Number of parents to keep in the next population. -1 means keep all parents and 0 means keep nothing.

crossover_type = "two_points" # Type of the crossover operator.

# Parameters of the mutation operation.
mutation_type = "random" # Type of the mutation operator.
mutation_percent_genes = 5 # Percentage of genes to mutate. This parameter has no action if the parameter mutation_num_genes exists or when mutation_type is None.

last_fitness = 0

def callback_generation(ga_instance):
    global last_fitness
    print("Generation = {generation}".format(generation=ga_instance.generations_completed))
    print("Fitness    = {fitness}".format(fitness=ga_instance.best_solution()[1]))
    print("Change     = {change}".format(change=ga_instance.best_solution()[1] - last_fitness))
    last_fitness = ga_instance.best_solution()[1]

# Creating an instance of the GA class inside the ga module. Some parameters are initialized within the constructor.

def fitness_wrapper(solution):
    print('fitness called')
    return fitness_func(solution, 0)


class PooledGA(pygad.GA):

    def cal_pop_fitness(self):
        global pool
        print('cal_fitness called')
        pop_fitness = pool.map(fitness_wrapper, self.population)
#         print(pop_fitness)
        pop_fitness = np.array(pop_fitness)
        return pop_fitness

ga_instance = PooledGA(num_generations=num_generations,
                       num_parents_mating=num_parents_mating, 
                       fitness_func=fitness_function,
                       sol_per_pop=sol_per_pop, 
                       num_genes=num_genes,
#                        init_range_low=init_range_low,
#                        init_range_high=init_range_high,
                       parent_selection_type=parent_selection_type,
                       keep_parents=keep_parents,
                       crossover_type=crossover_type,
                       mutation_type=mutation_type,
                       mutation_percent_genes=mutation_percent_genes,
                       on_generation=callback_generation,
                       gene_type=int,
                       gene_space=gene_space_int,
)

ga_instance = pygad.GA(num_generations=num_generations,
                       num_parents_mating=num_parents_mating, 
                       fitness_func=fitness_function,
                       sol_per_pop=sol_per_pop, 
                       num_genes=num_genes,
#                        init_range_low=init_range_low,
#                        init_range_high=init_range_high,
                       parent_selection_type=parent_selection_type,
                       keep_parents=keep_parents,
                       crossover_type=crossover_type,
                       mutation_type=mutation_type,
                       mutation_percent_genes=mutation_percent_genes,
                       on_generation=callback_generation,
                       gene_type=int,
                       gene_space=gene_space_int,
)


# In[14]:


get_ipython().run_cell_magic('time', '', '\n# Running the GA to optimize the parameters of the function.\nga_instance.run()\n\n# After the generations complete, some plots are showed that summarize the how the outputs/fitenss values evolve over generations.\nga_instance.plot_result()\n\n# Returning the details of the best solution.\nsolution, solution_fitness, solution_idx = ga_instance.best_solution()\nprint("Parameters of the best solution : {solution}".format(solution=solution))\nseq_aa = \'\'.join([codon_to_int[x] for x in solution])\nprint("NT Sequence of the best solution : {seq_aa}".format(seq_aa=seq_aa))\nprint("Fitness value of the best solution = {solution_fitness}".format(solution_fitness=solution_fitness))\nprint("Index of the best solution : {solution_idx}".format(solution_idx=solution_idx))\n\n# # prediction = numpy.sum(numpy.array(function_inputs)*solution) Replace\n# print("Predicted output based on the best solution : {prediction}".format(prediction=prediction))\n\nif ga_instance.best_solution_generation != -1:\n    print("Best fitness value reached after {best_solution_generation} generations.".format(best_solution_generation=ga_instance.best_solution_generation))\n\n# Saving the GA instance.\nfilename = \'genetic\' # The filename to which the instance is saved. The name is without extension.\nga_instance.save(filename=filename)\n\n# Loading the saved GA instance.\nloaded_ga_instance = pygad.load(filename=filename)\nloaded_ga_instance.plot_result()')


# In[15]:


get_ipython().run_cell_magic('time', '', '\nprint(\'Started\')\nwith Pool(processes=5) as pool:\n\n    # Running the GA to optimize the parameters of the funcabstion.\n    ga_instance.run()\n\n    # After the generations complete, some plots are showed that summarize the how the outputs/fitenss values evolve over generations.\n    ga_instance.plot_result()\n\n    # Returning the details of the best solution.\n    solution, solution_fitness, solution_idx = ga_instance.best_solution()\n    print("Parameters of the best solution : {solution}".format(solution=solution))\n    print("Fitness value of the best solution = {solution_fitness}".format(solution_fitness=solution_fitness))\n    print("Index of the best solution : {solution_idx}".format(solution_idx=solution_idx))\n\n    solution_aa = \'\'.join([codon_to_int[x] for x in solution])\n   \n    print("Predicted output based on the best solution : {prediction}".format(prediction=solution_aa))\n\n#     if ga_instance_pool.best_solution_generation != -1:\n#         print("Best fitness value reached after {best_solution_generation} generations.".format(best_solution_generation=ga_instance.best_solution_generation))\n\n    # Saving the GA instance.\n    filename = \'genetic\' # The filename to which the instance is saved. The name is without extension.\n    ga_instance.save(filename=filename)\n\n# Loading the saved GA instance.\nloaded_ga_instance = pygad.load(filename=filename)\nloaded_ga_instance.plot_result()')


# In[16]:


# solution_aa
# all_sols[seq_aa]


# In[17]:


get_ipython().run_cell_magic('time', '', "with Pool(processes=5) as pool:\n\nseq_aa = 'ATGAGACCTTTACGACCTCGGGCAGCGCTACTGGCATTGTTAGCTTCTTTATTGGCAGCTCCGCCAGTAGCCCCCGCGGAAGCTCCTCATCTCGTCCACGTTGACGCGGCCCGCGCCCTTTGGCCACTAAGGCGGTTCTGGAGAAGCACGGGTTTCTGTCCTCCCCTTCCGCATTCCCAAGCGGACCAGTATGTACTCTCATGGGATCAGCAACTGAATTTAGCCTATGTTGGTGCGGTCCCACACAGAGGGATCAAACAGGTGCGCACCCATTGGCTATTGGAATTGGTTACAACCAGGGGCAGTACTGGCAGAGGGCTGAGCTACAATTTTACGCATCTGGACGGCTACTTAGATCTTCTCAGGGAGAACCAACTACTCCCGGGCTTCGAACTGATGGGAAGTGCCTCCGGGCACTTTACTGATTTCGAGGACAAGCAACAAGTCTTCGAGTGGAAAGATTTAGTCTCGTCTTTGGCTCGCAGGTATATTGGTAGGTACGGGCTAGCGCACGTTTCTAAATGGAATTTTGAAACGTGGAACGAGCCCGACCATCACGACTTCGACAACGTATCGATGACTATGCAGGGGTTTCTCAACTATTATGATGCTTGTAGCGAAGGGCTTAGGGCGGCCTCGCCTGCCCTTCGGCTGGGCGGGCCCGGGGACTCGTTCCATACCCCACCCCGATCCCCATTATCTTGGGGCCTGCTCCGCCATTGCCATGATGGGACGAACTTCTTCACAGGCGAGGCAGGCGTTCGCTTGGACTATATCAGTCTACACCGCAAGGGCGCCCGCTCGAGTATTTCTATCTTAGAGCAGGAAAAAGTGGTGGCGCAGCAAATACGACAATTGTTCCCTAAGTTCGCTGACACACCAATATACAATGACGAGGCAGATCCTCTGGTTGGCTGGTCGTTGCCCCAGCCCTGGCGGGCAGATGTCACCTATGCCGCCATGGTCGTTAAAGTGATAGCACAGCACCAAAATCTTCTACTTGCTAACACGACCAGTGCCTTTCCATACGCTCTATTGTCGAACGATAATGCCTTCTTATCGTACCACCCACATCCGTTTGCCCAGAGAACTCTGACCGCTCGTTTTCAAGTTAATAACACCCGACCGCCGCATGTCCAGCTATTAAGGAAGCCGGTCTTAACCGCCATGGGGCTCCTCGCGCTGCTTGATGAAGAACAACTATGGGCGGAGGTGTCGCAAGCTGGCACTGTCCTAGATTCGAACCATACAGTTGGAGTCTTGGCCTCCGCTCACCGTCCACAAGGACCCGCAGATGCATGGAGGGCAGCGGTTCTAATCTACGCATCTGATGATACCCGGGCTCACCCGAATCGATCGGTAGCAGTTACCCTGCGTCTACGTGGTGTGCCTCCAGGACCGGGTCTAGTCTACGTCACGCGATATCTTGACAATGGCCTATGCAGTCCTGACGGGGAATGGCGGCGCCTCGGTCGACCGGTTTTTCCAACAGCAGAACAGTTTCGACGCATGAGAGCTGCAGAAGATCCTGTAGCAGCAGCCCCCAGGCCATTACCAGCCGGGGGTCGCCTAACACTACGCCCGGCCCTCCGACTTCCATCGTTACTGTTGGTCCATGTCTGCGCACGGCCCGAAAAACCCCCCGGACAAGTCACCCGATTACGAGCGCTTCCATTGACTCAGGGACAGCTAGTGTTGGTATGGTCGGACGAGCATGTTGGTAGTAAGTGCTTGTGGACATACGAAATACAGTTTTCACAAGACGGCAAGGCCTATACGCCGGTATCGAGAAAGCCGTCCACCTTTAATCTATTCGTATTTTCACCTGACACCGGGGCAGTATCCGGGTCTTACCGCGTTCGTGCTTTAGATTACTGGGCTAGGCCCGGGCCATTTTCCGATCCGGTTCCATATTTAGAGGTTCCGGTACCACGAGGTCCTCCCTCCCCTGGGAATCCGTAA'\nfitness_func(seq_aa,0)")

